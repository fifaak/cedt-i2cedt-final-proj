const express = require("express");
const cors = require("cors");
const https = require("https");
const localStorage = require("./storage/localStorage");
const { MongoSync } = require("./services/mongoSync");
require("dotenv").config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true }));

// Request timeout middleware
app.use((req, res, next) => {
  res.setTimeout(30000, () => res.status(408).json({ error: "Request timeout" }));
  next();
});

// Mount routes
const chatRoutes = require('./routes/chat');
app.use('/api/chat', chatRoutes);

// Helper function for HTTPS requests (Node 18+ compatible)
function makeHttpsRequest(url, options) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const requestOptions = {
      hostname: urlObj.hostname,
      port: urlObj.port || 443,
      path: urlObj.pathname + urlObj.search,
      method: options.method || 'GET',
      headers: {
        'User-Agent': 'Thai-Fortune-API/1.0',
        ...options.headers
      },
      timeout: 30000 // 30 second timeout
    };

    const req = https.request(requestOptions, (res) => {
      let data = '';
      res.setEncoding('utf8');
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        try {
          resolve({
            ok: res.statusCode >= 200 && res.statusCode < 300,
            status: res.statusCode,
            statusText: res.statusMessage,
            json: () => Promise.resolve(JSON.parse(data)),
            text: () => Promise.resolve(data)
          });
        } catch (parseError) {
          reject(new Error(`Failed to parse response: ${parseError.message}`));
        }
      });
    });

    req.on('error', (error) => {
      reject(new Error(`Request failed: ${error.message}`));
    });

    req.on('timeout', () => {
      req.destroy();
      reject(new Error('Request timeout'));
    });

    if (options.body) {
      req.write(options.body);
    }
    req.end();
  });
}

// Initialize services
console.log("üîÑ Initializing storage and sync services...");
const mongoSync = new MongoSync();
mongoSync.startPeriodicSync(10000); // Sync every 10 seconds

async function getAiPrediction(userInfo, userMessage) {
  const API_KEY = process.env.TYPHOON_API_KEY;
  const API_ENDPOINT = "https://api.opentyphoon.ai/v1/chat/completions";

  if (!API_KEY) {
    console.error("‚ùå TYPHOON_API_KEY not found in environment variables");
    return "‡πÑ‡∏°‡πà‡∏û‡∏ö API Key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ AI ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤";
  }

  const systemPrompt = `‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ "‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡∏Ñ‡∏°" ‡∏´‡∏°‡∏≠‡∏î‡∏π‡∏™‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡∏î‡∏ß‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏Å‡πÇ‡∏´‡∏£‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå ‡πÅ‡∏•‡∏∞ ‡∏î‡∏ß‡∏á‡∏ä‡∏∞‡∏ï‡∏≤ ‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ ‡∏ï‡∏£‡∏á‡πÑ‡∏õ‡∏ï‡∏£‡∏á‡∏°‡∏≤, ‡∏Ç‡∏ß‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ã‡∏≤‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏∞‡∏ï‡∏∏‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏Ñ‡∏ô‡∏ü‡∏±‡∏á‡∏ï‡∏∑‡πà‡∏ô‡∏à‡∏≤‡∏Å‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡∏µ‡πâ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á", ‡∏à‡∏∏‡∏î‡∏≠‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏ß‡∏Å‡πÄ‡∏Ç‡∏≤‡∏≠‡∏≤‡∏à‡∏°‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏°, ‡πÅ‡∏•‡∏∞‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏≥‡∏à‡∏£‡∏¥‡∏á ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏à‡∏•‡∏≠‡∏¢‡πÜ ‡∏à‡∏á‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÅ‡∏ö‡∏ö‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö, ‡πÄ‡∏ô‡πâ‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏î‡πâ ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏û‡∏π‡∏î‡∏ñ‡∏∂‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏ô‡πÅ‡∏á‡πà‡∏•‡∏ö‡∏ñ‡πâ‡∏≤‡∏î‡∏ß‡∏á‡∏ä‡∏∞‡∏ï‡∏≤‡∏°‡∏±‡∏ô‡∏ä‡∏µ‡πâ‡πÑ‡∏õ‡∏ó‡∏≤‡∏á‡∏ô‡∏±‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡∏ï‡∏≠‡∏ö‡πÅ‡∏ö‡∏ö‡∏™‡∏±‡πâ‡∏ô‡πÜ ‡∏ã‡∏±‡∏Å 4-5 ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ ‡πÅ‡∏ï‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏à‡∏Ñ‡∏ß‡∏≤‡∏°
---
‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ:
- ‡∏ä‡∏∑‡πà‡∏≠: ${userInfo.name}
- ‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î: ${userInfo.birthdate}
- ‡πÄ‡∏û‡∏®: ${userInfo.sex}
- ‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏Å‡∏±‡∏á‡∏ß‡∏•: ${userInfo.topic}
---`;

  const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: userMessage },
  ];

  try {
    const response = await makeHttpsRequest(API_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${API_KEY}`,
      },
      body: JSON.stringify({
        model: "typhoon-v2.1-12b-instruct",
        messages: messages,
        temperature: 0.7,
        max_tokens: 256,
        top_p: 0.8,
        repetition_penalty: 1.1,
        stream: false,
      }),
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  } catch (error) {
    console.error("‚ùå AI API Error:", error.message);
    return "‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡∏•‡πà‡∏° ‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏ó‡∏µ";
  }
}

// Input validation middleware
const validateFortuneInput = (req, res, next) => {
  const { name, birthdate, sex, topic, text } = req.body;

  if (!name || !birthdate || !sex || !topic || !text) {
    return res.status(400).json({
      error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô",
    });
  }

  // Validate birthdate format
  const dateRegex = /^\d{2}\/\d{2}\/\d{4}$/;
  if (!dateRegex.test(birthdate)) {
    return res.status(400).json({
      error: "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö DD/MM/YYYY",
    });
  }

  // Validate enum values
  const validSex = ["male", "female", "other"];
  const validTopics = ["overall", "career", "finance", "love", "health"];

  if (!validSex.includes(sex)) {
    return res.status(400).json({ error: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏®‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
  }

  if (!validTopics.includes(topic)) {
    return res.status(400).json({ error: "‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
  }

  next();
};

// Routes
app.post("/api/fortune", validateFortuneInput, async (req, res) => {
  try {
    const { name, birthdate, sex, topic, text } = req.body;

    // Get AI prediction
    const userInfo = { name, birthdate, sex, topic };
    const prediction = await getAiPrediction(userInfo, text);

    // Save to local storage
    const savedFortune = await localStorage.createFortune({
      name: name.trim(),
      birthdate,
      sex,
      topic,
      text: text.trim(),
      prediction,
    });

    console.log(`‚úÖ New fortune created for ${name}`);

    res.status(201).json({
      id: savedFortune.id,
      prediction: savedFortune.prediction,
    });
  } catch (error) {
    console.error("‚ùå Error creating fortune:", error);
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á" });
  }
});

app.get("/api/fortune", async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50; // Default limit
    const page = parseInt(req.query.page) || 1;

    const result = await localStorage.getFortunes({ limit, page });

    res.json({
      fortunes: result.fortunes.map((fortune) => ({
        id: fortune.id,
        name: fortune.name,
        birthdate: fortune.birthdate,
        sex: fortune.sex,
        topic: fortune.topic,
        prediction: fortune.prediction,
        created_at: fortune.created_at,
      })),
      pagination: result.pagination,
    });
  } catch (error) {
    console.error("‚ùå Error fetching fortunes:", error);
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•" });
  }
});

app.get("/api/fortune/:id", async (req, res) => {
  try {
    const fortune = await localStorage.getFortuneById(req.params.id);

    if (!fortune) {
      return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á" });
    }

    res.json({
      id: fortune.id,
      name: fortune.name,
      birthdate: fortune.birthdate,
      sex: fortune.sex,
      topic: fortune.topic,
      prediction: fortune.prediction,
      created_at: fortune.created_at,
    });
  } catch (error) {
    console.error("‚ùå Error fetching fortune:", error);
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•" });
  }
});

app.put("/api/fortune/:id", validateFortuneInput, async (req, res) => {
  try {
    const { name, birthdate, sex, topic, text } = req.body;

    // Get new prediction with updated info
    const userInfo = { name, birthdate, sex, topic };
    const prediction = await getAiPrediction(
      userInfo,
      text || "‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á"
    );

    const updatedFortune = await localStorage.updateFortune(req.params.id, {
      name: name.trim(),
      birthdate,
      sex,
      topic,
      text: text.trim(),
      prediction,
    });

    if (!updatedFortune) {
      return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á" });
    }

    console.log(`‚úÖ Fortune updated for ${name}`);

    res.json({
      id: updatedFortune.id,
      name: updatedFortune.name,
      birthdate: updatedFortune.birthdate,
      sex: updatedFortune.sex,
      topic: updatedFortune.topic,
      prediction: updatedFortune.prediction,
    });
  } catch (error) {
    console.error("‚ùå Error updating fortune:", error);
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï" });
  }
});

app.delete("/api/fortune/:id", async (req, res) => {
  try {
    const deletedFortune = await localStorage.deleteFortune(req.params.id);

    if (!deletedFortune) {
      return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á" });
    }

    console.log(`üóëÔ∏è  Fortune deleted: ${deletedFortune.name}`);
    res.json({ success: true, message: "‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
  } catch (error) {
    console.error("‚ùå Error deleting fortune:", error);
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•" });
  }
});

app.post("/api/chat", async (req, res) => {
  try {
    const { message, userInfo } = req.body;

    if (!message || !userInfo) {
      return res.status(400).json({
        error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ",
      });
    }

    const prediction = await getAiPrediction(userInfo, message);

    res.json({ prediction });
  } catch (error) {
    console.error("Error in chat:", error);
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏ó‡∏ô‡∏≤" });
  }
});

// Manual sync endpoint
app.post("/api/sync", async (req, res) => {
  try {
    const result = await mongoSync.manualSync();
    res.json({
      success: result.success,
      message: result.success ? "Sync completed successfully" : "Sync failed",
      details: result.results || result.reason,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error("Error in manual sync:", error);
    res.status(500).json({ 
      success: false,
      error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•",
      details: error.message 
    });
  }
});

// Sync status endpoint
app.get("/api/sync/status", (req, res) => {
  const status = mongoSync.getSyncStatus();
  res.json({
    ...status,
    timestamp: new Date().toISOString()
  });
});

// Health check endpoint
app.get("/api/health", (req, res) => {
  const syncStatus = mongoSync.getSyncStatus();
  
  res.json({
    status: "OK",
    timestamp: new Date().toISOString(),
    storage: {
      type: "hybrid",
      local: "connected",
      mongodb: syncStatus.isConnected ? "connected" : "disconnected"
    },
    sync: {
      active: syncStatus.syncActive,
      mongoState: syncStatus.mongoState,
      connectionAttempts: syncStatus.connectionAttempts
    },
    nodeVersion: process.version,
    environment: process.env.NODE_ENV || "development"
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error("Server Error:", err.stack);
  res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå" });
});

// 404 handler
app.use("*", (req, res) => {
  res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£" });
});

// Graceful shutdown
process.on("SIGTERM", async () => {
  console.log("üõë SIGTERM received, shutting down gracefully");
  mongoSync.stopPeriodicSync();
  console.log("üì¶ Local storage data saved");
  process.exit(0);
});

process.on("SIGINT", async () => {
  console.log("üõë SIGINT received, shutting down gracefully");
  mongoSync.stopPeriodicSync();
  console.log("üì¶ Local storage data saved");
  process.exit(0);
});

// Start server
app.listen(PORT, () => {
  console.log(`üîÆ Fortune Telling API Server running on port ${PORT}`);
  console.log(`üåê API available at: http://localhost:${PORT}/api`);
  console.log(`‚ù§Ô∏è  Health check: http://localhost:${PORT}/api/health`);
});

module.exports = app;
